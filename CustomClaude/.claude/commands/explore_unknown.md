# /explore_unknown - SuperClaude Unknown Codebase Exploration Templates

```yaml
---
command: "/explore_unknown"
category: "Analysis & Templates"
purpose: "Systematic exploration templates for completely unknown codebases"
wave-enabled: true
performance-profile: "optimization"
origin: "SuperClaude systematic analysis ‚Üí unknown codebase mastery"
---
```

## üéØ **Command Purpose**

**Core Mission**: Provide systematic exploration templates for encountering completely unknown codebases
**SuperClaude Integration**: Evidence-based exploration with persona coordination and compound intelligence
**Practical Focus**: Transform overwhelming complexity into manageable, systematic understanding

## ‚öôÔ∏è **Auto-Persona Activation**

- **analyzer**: Deep codebase structural analysis, pattern recognition, complexity assessment
- **architect**: System design understanding, component relationship mapping
- **mentor**: Learning pathway creation, knowledge prioritization, understanding validation

## üìä **Exploration Template Framework**

### **Initial Contact Protocol**
```markdown
# Unknown Codebase: First Contact Analysis

## Immediate Assessment (5 minutes)
- [ ] **Language Identification**: What programming language(s)?
- [ ] **Project Type**: Web app, CLI tool, library, service, desktop app?
- [ ] **Size Estimate**: Small (<1k files), Medium (1k-10k), Large (>10k)?
- [ ] **Age Indicators**: Last commit date, dependency versions, code style era
- [ ] **Documentation**: README quality, inline docs, external docs

## Quick Structure Scan (10 minutes)
- [ ] **Entry Points**: Main files, startup scripts, primary modules
- [ ] **Directory Layout**: Standard conventions vs custom organization
- [ ] **Configuration**: Config files, environment variables, build systems
- [ ] **Dependencies**: Package managers, external libraries, services
- [ ] **Tests**: Test directories, testing frameworks, coverage

## Risk & Complexity Assessment (10 minutes)
- [ ] **Complexity Indicators**: Deeply nested directories, large files, complex imports
- [ ] **Legacy Markers**: Old language versions, deprecated dependencies, outdated patterns
- [ ] **Quality Signals**: Consistent naming, clear structure, good separation of concerns
- [ ] **Modification Risk**: Tightly coupled code, missing tests, unclear interfaces
- [ ] **Learning Curve**: Documentation quality, code clarity, pattern consistency

## Initial Understanding Score
**Language Familiarity**: [1-10] How well do you know the primary language?
**Domain Knowledge**: [1-10] How familiar are you with the problem domain?
**Architecture Clarity**: [1-10] How clear is the system architecture?
**Modification Confidence**: [1-10] How confident are you about making changes?

**Overall Assessment**: [Ready to proceed / Need more exploration / Requires expert help]
```

### **Systematic Deep Dive Template**
```markdown
# Deep Codebase Analysis: [Project Name]

## Phase 1: Foundation Understanding
### Technology Stack Analysis
**Primary Language**: [Language + version]
**Framework/Libraries**: [Main frameworks and their versions]
**Database/Storage**: [Data persistence solutions]
**Build System**: [How the project builds and runs]
**Deployment**: [How the project gets deployed]

### Architecture Pattern Recognition
**Overall Pattern**: [Monolith/Microservices/Serverless/Other]
**Code Organization**: [How code is structured and separated]
**Data Flow**: [How data moves through the system]
**External Integrations**: [APIs, services, databases used]
**Configuration Management**: [How settings and config are handled]

## Phase 2: Component Mapping
### Core Components
```yaml
component_inventory:
  [Component 1]:
    purpose: "[What it does]"
    location: "[File/directory path]"
    dependencies: "[What it depends on]"
    interfaces: "[How others interact with it]"
    
  [Component 2]:
    purpose: "[What it does]"
    location: "[File/directory path]"
    dependencies: "[What it depends on]"
    interfaces: "[How others interact with it]"
```

### Data Models & Structures
```yaml
data_architecture:
  [Model 1]:
    definition: "[Where defined]"
    usage: "[How it's used throughout system]"
    relationships: "[Connected to which other models]"
    
  [Model 2]:
    definition: "[Where defined]"
    usage: "[How it's used throughout system]"
    relationships: "[Connected to which other models]"
```

## Phase 3: Implementation Pattern Analysis
### Common Patterns Discovered
- **Pattern 1**: [Pattern name] - [Where used] - [How it works]
- **Pattern 2**: [Pattern name] - [Where used] - [How it works]
- **Pattern 3**: [Pattern name] - [Where used] - [How it works]

### Code Conventions
- **Naming**: [How variables, functions, classes are named]
- **File Organization**: [How files are organized and named]
- **Error Handling**: [How errors are handled throughout system]
- **Logging**: [How logging is implemented and used]
- **Testing**: [Testing patterns and conventions used]

### Quality Assessment
- **Code Quality**: [Overall code quality assessment]
- **Test Coverage**: [How well tested the system is]
- **Documentation**: [Quality and completeness of documentation]
- **Technical Debt**: [Areas needing improvement or refactoring]

## Phase 4: Modification Strategy
### Safe Areas for Changes
- **Low Risk**: [Areas safe to modify with minimal impact]
- **Medium Risk**: [Areas requiring careful testing and validation]
- **High Risk**: [Areas to avoid or approach with extreme caution]

### Implementation Patterns for Changes
- **Adding Features**: [How new features are typically added]
- **Bug Fixes**: [How bugs are typically identified and fixed]
- **Configuration**: [How to modify system behavior through config]
- **Testing**: [How to test changes effectively]

### Development Workflow
- **Local Setup**: [How to get the system running locally]
- **Making Changes**: [Typical workflow for making modifications]
- **Testing Changes**: [How to validate changes work correctly]
- **Deployment**: [How changes get deployed to production]
```

## üöÄ **Exploration Command Patterns**

### **Quick Assessment**
```bash
/explore_unknown @new_repo/ --first-contact --rapid-assessment
/explore_unknown --structure-scan --risk-analysis --time-boxed
```

### **Systematic Deep Dive**
```bash
/explore_unknown @complex_system/ --wave-mode --comprehensive --evidence-based
/explore_unknown --systematic --component-mapping --pattern-analysis
```

### **Implementation-Focused Exploration**
```bash
/explore_unknown @target_area/ --modification-focused --safe-patterns
/explore_unknown --implementation-ready --risk-assessed --context-export
```

## üß† **Specialized Exploration Templates**

### **Legacy System Archaeology**
```markdown
# Legacy System Exploration: [System Name]

## Archaeological Approach
**Time Period Analysis**: [When was this built? What era of practices?]
**Technology Evolution**: [How have the technologies evolved since then?]
**Historical Context**: [What problems was this solving at the time?]
**Survival Patterns**: [What has kept this system working over time?]

## Legacy-Specific Risks
- **Deprecated Dependencies**: [Old libraries that may have security issues]
- **Obsolete Patterns**: [Practices that are no longer recommended]
- **Missing Documentation**: [Institutional knowledge that may be lost]
- **Update Constraints**: [What prevents easy updates or changes]

## Modernization Opportunities
- **Quick Wins**: [Easy improvements that reduce risk]
- **Strategic Updates**: [Larger changes that provide significant value]
- **Migration Paths**: [How to gradually modernize without breaking things]
```

### **Microservices System Exploration**
```markdown
# Microservices System Exploration: [System Name]

## Service Inventory
```yaml
services:
  [Service 1]:
    purpose: "[What business function it serves]"
    technology: "[Language/framework used]"
    data: "[What data it manages]"
    interfaces: "[APIs it exposes]"
    dependencies: "[What services it depends on]"
    
  [Service 2]:
    purpose: "[What business function it serves]"
    technology: "[Language/framework used]"
    data: "[What data it manages]"
    interfaces: "[APIs it exposes]"  
    dependencies: "[What services it depends on]"
```

## Inter-Service Communication
- **Synchronous**: [REST APIs, GraphQL, gRPC usage patterns]
- **Asynchronous**: [Message queues, event streams, pub/sub patterns]
- **Data Consistency**: [How consistency is maintained across services]
- **Error Handling**: [How failures are handled across service boundaries]

## System-Level Patterns
- **Service Discovery**: [How services find each other]
- **Configuration**: [How configuration is distributed]
- **Monitoring**: [How system health is monitored]
- **Deployment**: [How services are deployed and updated]
```

### **AI/ML System Exploration**
```markdown
# AI/ML System Exploration: [System Name]

## ML Pipeline Analysis
**Data Pipeline**: [How data flows from sources to models]
**Model Architecture**: [Types of models and their purposes]
**Training Process**: [How models are trained and updated]
**Inference System**: [How models are served and used]
**Evaluation**: [How model performance is measured]

## AI-Specific Considerations
- **Data Dependencies**: [What data sources are critical]
- **Model Versioning**: [How model updates are managed]
- **Performance Requirements**: [Latency, throughput, accuracy needs]
- **Monitoring**: [How model performance is tracked in production]
- **Bias/Fairness**: [How fairness and bias are addressed]
```

## üé™ **Practical Exploration Scenarios**

### **Open Source Project Contribution**
```bash
# Scenario: Want to contribute to unfamiliar open source project
/explore_unknown @oss_project/ --contribution-focused --community-patterns

# Output Focus:
# - How contributions are typically made
# - Code style and contribution guidelines
# - Testing requirements for contributions
# - Review process and maintainer expectations
```

### **Legacy System Maintenance**
```bash
# Scenario: Inherited maintenance of legacy system
/explore_unknown @legacy_system/ --archaeological --risk-focused

# Output Focus:
# - Historical context and original design decisions
# - Areas of highest risk for changes
# - Safe modification patterns for legacy code
# - Modernization opportunities and migration paths
```

### **Emergency Bug Fix**
```bash
# Scenario: Critical bug in unfamiliar system
/explore_unknown @bug_area/ --surgical --minimal-risk --time-critical

# Output Focus:
# - Rapid understanding of bug area
# - Safe patterns for making minimal fixes
# - Testing strategy for emergency changes
# - Rollback plans if fix causes issues
```

## üîß **Quality Gates & Validation**

### **Understanding Validation Checklist**
- [ ] Can explain system purpose to someone else
- [ ] Can identify where to make common types of changes
- [ ] Can explain how to test changes safely  
- [ ] Can identify areas of highest risk
- [ ] Can find similar implementations for reference
- [ ] Can set up development environment
- [ ] Can run existing tests and see them pass
- [ ] Can make a minimal, safe change and test it

### **Readiness Assessment**
```yaml
readiness_criteria:
  basic_understanding: "Know what the system does and how it's organized"
  modification_confidence: "Can identify safe areas for changes"
  testing_capability: "Know how to validate changes work correctly"
  risk_awareness: "Understand what could go wrong and how to mitigate"
  pattern_recognition: "Can find similar implementations for reference"
```

## üéØ **Strategic Benefits**

**Systematic Approach**: Reduces overwhelming complexity to manageable steps
**Risk Mitigation**: Identifies dangers before they cause problems  
**Confidence Building**: Structured exploration builds understanding systematically
**Pattern Recognition**: Builds library of exploration approaches for different system types
**Knowledge Transfer**: Templates work for team members at different experience levels

**Ultimate Goal**: Transform the challenge of understanding unknown codebases from overwhelming complexity into systematic, confidence-building exploration that enables safe and effective implementation work.