# /discover_codebase - SuperClaude Unknown Codebase Analysis

```yaml
---
command: "/discover_codebase"
category: "Analysis & Discovery"
purpose: "Systematic codebase exploration and context building for unknown projects"
wave-enabled: true
performance-profile: "optimization"
origin: "SuperClaude systematic analysis â†’ agentic discovery patterns"
---
```

## ðŸŽ¯ **Command Identity & Purpose**

**Core Function**: Rapidly understand unknown codebases through systematic analysis and context extraction
**SuperClaude Integration**: Uses persona orchestration, MCP coordination, and wave strategies for comprehensive codebase understanding
**Agentic Approach**: Multi-stage autonomous exploration with minimal human guidance

## âš™ï¸ **Auto-Persona Activation**

- **analyzer**: Deep code analysis, architecture discovery, pattern recognition
- **architect**: System design understanding, dependency mapping, structure analysis  
- **mentor**: Learning pathway creation, knowledge synthesis, best practice identification

## ðŸ§  **MCP Server Orchestration**

- **Primary**: Sequential - Multi-stage codebase exploration and analysis
- **Secondary**: Context7 - Documentation extraction and knowledge synthesis
- **Tertiary**: Magic - Visual architecture mapping when applicable

## ðŸ“Š **Discovery Framework**

### **Wave Strategy: Progressive Understanding**
```yaml
wave_1_surface:
  - Project structure analysis
  - README and documentation scan
  - Package/dependency identification
  - Entry point discovery

wave_2_architecture:
  - Core module identification
  - Data flow analysis
  - API surface mapping
  - Configuration discovery

wave_3_implementation:
  - Code pattern analysis
  - Business logic extraction
  - Integration point identification
  - Quality assessment
```

### **Systematic Analysis Pipeline**
```yaml
discovery_stages:
  1. **Structural Analysis**: Directory tree, file organization, naming patterns
  2. **Dependency Mapping**: Libraries, frameworks, external services
  3. **Entry Point Identification**: Main files, startup sequences, core loops
  4. **API Surface Discovery**: Endpoints, interfaces, public methods
  5. **Data Flow Analysis**: Models, schemas, data transformations
  6. **Configuration Analysis**: Environment variables, config files, settings
  7. **Documentation Synthesis**: Extract implicit knowledge, create context maps
```

## ðŸš€ **Command Execution Patterns**

### **Basic Discovery**
```bash
/discover_codebase @project_root/ --systematic
/discover_codebase @unknown_repo/ --focus architecture
/discover_codebase . --minimal-knowledge --create-context
```

### **Advanced Agentic Analysis**
```bash
/discover_codebase --wave-mode --autonomous --think-hard
/discover_codebase @complex_system/ --delegate --persona-analyzer
/discover_codebase --pattern-extraction --learning-focused
```

### **SuperClaude Integration**
```bash
/discover_codebase | /analyze --deep-dive
/discover_codebase --export-knowledge > AI_docs/codebase_context.md
/discover_codebase --create-specs --implementation-ready
```

## ðŸ“‹ **Knowledge Extraction Templates**

### **Codebase Context Map**
```markdown
# Codebase Context: [Project Name]

## High-Level Overview
**Purpose**: [What this codebase does]
**Domain**: [Business/technical domain]
**Scale**: [Size, complexity, maturity level]
**Architecture**: [Monolith/microservices/other]

## Technical Stack
**Language**: [Primary language + versions]
**Framework**: [Main framework/libraries]
**Database**: [Data storage solutions]
**Infrastructure**: [Deployment, hosting, services]

## Entry Points & Core Flows
**Main Entry**: [Primary application entry point]
**Key Workflows**: [Major user/system workflows]
**Data Flow**: [How data moves through system]
**External Integrations**: [Third-party services, APIs]

## Implementation Patterns
**Code Organization**: [How code is structured]
**Common Patterns**: [Repeated design patterns]
**Configuration**: [How settings/config work]
**Error Handling**: [Error management approach]

## Modification Guidelines
**Safe Areas**: [Low-risk areas for changes]
**Complex Areas**: [High-risk, complex subsystems]
**Testing Strategy**: [How to validate changes]
**Development Workflow**: [Local setup, testing, deployment]
```

### **Implementation Context Primer**
```markdown
# Implementation Context: [Feature/Change]

## Current Understanding
**Target Area**: [Specific part of codebase to modify]
**Related Components**: [Connected systems/modules]
**Data Dependencies**: [Data structures, models involved]
**Business Logic**: [Relevant business rules/logic]

## Change Strategy
**Approach**: [How to implement without breaking things]
**Risk Assessment**: [What could go wrong]
**Validation Plan**: [How to test changes]
**Rollback Strategy**: [How to undo if needed]

## Agentic Implementation Plan
1. **Isolated Analysis**: Understand target area in detail
2. **Pattern Matching**: Find similar implementations in codebase
3. **Minimal Implementation**: Make smallest viable change
4. **Incremental Testing**: Validate each step
5. **Integration Verification**: Ensure system-wide compatibility
```

## ðŸ§  **Agentic Discovery Patterns**

### **Autonomous Exploration**
```yaml
exploration_agents:
  structure_agent:
    focus: "Directory layout, file organization, naming conventions"
    output: "Structural understanding, navigation map"
    
  dependency_agent:
    focus: "Libraries, frameworks, external services"
    output: "Technology stack, integration points"
    
  pattern_agent:
    focus: "Code patterns, architectural decisions"
    output: "Implementation guidelines, best practices"
    
  flow_agent:
    focus: "Data flow, control flow, user journeys"
    output: "System behavior understanding"
```

### **Learning-Focused Analysis**
```yaml
learning_pipeline:
  1. **Observe**: What patterns exist in the codebase?
  2. **Analyze**: Why were these patterns chosen?
  3. **Extract**: What principles can be generalized?
  4. **Synthesize**: How to apply to new implementations?
  5. **Validate**: Test understanding through small changes
```

## ðŸŽª **Practical Discovery Workflows**

### **Unknown Repository Analysis**
```bash
# First encounter with new codebase
/discover_codebase @new_repo/ --wave-mode --comprehensive

# Output:
# - AI_docs/codebase_context.md (comprehensive understanding)
# - specs/architecture_analysis.md (system design)
# - dotcloud/implementation_patterns.md (reusable approaches)
```

### **Feature Implementation Preparation**
```bash
# Preparing to add feature to unknown codebase
/discover_codebase @target_area/ --focus implementation --minimal-risk

# Output:
# - specs/features/safe_implementation_approach.md
# - AI_docs/modification_guidelines.md
# - dotcloud/testing_validation_prompts.md
```

### **Legacy System Understanding**
```bash
# Making sense of legacy/undocumented code
/discover_codebase @legacy_system/ --archaeological --patience-mode

# Output:
# - AI_docs/legacy_understanding.md (reverse-engineered docs)
# - specs/modernization_opportunities.md (improvement areas)
# - dotcloud/safe_modification_patterns.md (proven approaches)
```

## ðŸ”§ **Quality Gates & Validation**

### **Understanding Verification**
```yaml
verification_checks:
  structural: "Can navigate codebase confidently"
  functional: "Understand main user/system workflows"
  technical: "Know key technologies and patterns"
  modification: "Identify safe areas for changes"
  testing: "Know how to validate modifications"
```

### **Knowledge Completeness**
```yaml
completeness_metrics:
  architecture: "System design understanding (80%+ coverage)"
  dependencies: "External integration mapping (complete)"
  patterns: "Implementation pattern catalog (sufficient)"
  risks: "High-risk area identification (documented)"
  workflow: "Development process understanding (actionable)"
```

## ðŸŽ¯ **Strategic Alignment**

**SuperClaude Principles**: Evidence-based analysis, systematic exploration, compound intelligence
**Agentic Approach**: Autonomous discovery, minimal guidance, learning-focused
**Practical Focus**: Immediate implementation readiness, risk mitigation, knowledge synthesis

**Ultimate Goal**: Transform unknown codebase encounters into systematic understanding that enables confident implementation with minimal risk and maximum learning efficiency.