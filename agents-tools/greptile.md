**Using Model:** Gemini - gemini-2.5-flash-preview-04-17
#greptile #AI_coding 
### explain_docs

START OUTPUT SECTIONS

# OVERVIEW

What It Does: Greptile performs advanced codebase search to find patterns, existing code, edge cases, and dependencies within a project or organization's repositories.

Why People Use It: It helps developers plan features by finding existing patterns, implementations, and dependencies in the codebase, preventing redundant work and ensuring architectural consistency.

# HOW TO USE IT

Most Common Syntax: `"<search query>" [filter:value]`

# COMMON USE CASES

For Finding Existing Similar Code: `"<keyword related to code function>"`
For Finding Integration Examples: `"<type of integration> integration examples"`
For Finding Database Schema Examples: `"database schema <entity name>"`
For Finding Recent Code Changes: `"<keyword> modified:recent"`
For Finding Code in a Specific Language: `"<keyword>" language:<language>`
For Finding Code in a Specific Repository: `"<keyword>" repo:<repo_name>"`

# MOST IMPORTANT AND USED OPTIONS AND FEATURES

**Codebase Search**: Allows searching across the entire codebase to find relevant code snippets, functions, or files. Useful for discovering existing implementations.
**Identifying Patterns**: Helps recognize recurring code structures or solutions within the codebase. Useful for promoting consistency and reusability.
**Identifying Existing Implementations**: Finds specific examples of how certain features or integrations have been built previously. Useful for accelerating development and avoiding reinvention.
**Identifying Edge Cases**: Helps uncover potential issues or non-standard scenarios handled in existing code. Useful for writing robust and complete features.
**Identifying Dependencies**: Shows relationships between different parts of the codebase. Useful for understanding the impact of changes or finding required components.
**Filtering by Language (`language:<lang>`)**: Narrows search results to a specific programming language. Useful for finding relevant code in the desired technology stack.
**Filtering by Repository (`repo:<repo_name>`)**: Limits the search to a particular repository. Useful for focusing on specific parts of the organization's code.
**Filtering by Modification Time (`modified:recent`)**: Shows results from recently changed code. Useful for finding the latest examples or active development areas.

END OUTPUT SECTIONS

### extract_wisdom

## SUMMARY

This guide details integrating Greptile, a codebase search tool, into an AI-driven development workflow to achieve enterprise-level feature implementation standards.

## IDEAS:

*   Greptile enhances development by identifying codebase patterns, existing implementations, edge cases, and dependencies effectively.
*   Integrating Greptile into a blueprint-driven AI workflow elevates the development process to enterprise standards successfully.
*   Generating a high-level feature blueprint is the crucial initial step in this structured development approach.
*   Defining clear inputs, outputs, dependencies, edge cases, tests, and acceptance criteria structures the blueprint.
*   Performing a targeted Greptile search using blueprint keywords happens before any coding begins.
*   Searching for existing similar endpoints, routes, or services prevents redundant work and maintains consistency.
*   Finding relevant integration examples like "Slack webhook integration" leverages prior successful patterns efficiently.
*   Reviewing database schema examples ensures new features align with existing data structures seamlessly.
*   Examining recent similar PRs or commits provides context and examples of successful past implementations.
*   Targeted Greptile queries use specific keywords, languages, repositories, or modification dates precisely.
*   Leveraging existing patterns identified by Greptile prevents redundant work and guarantees architectural consistency reliably.
*   Using Greptile's findings allows refinement of the initial AI-generated feature blueprint effectively.
*   Updating the blueprint with proven patterns ensures the design is based on successful existing code.
*   Clearly identifying reusable components from Greptile results promotes code efficiency and maintainability significantly.
*   Specifying integration points explicitly, like extending existing logic, clarifies implementation details precisely.
*   Prompting AI with Greptile search results helps update the blueprint with best matching components intelligently.
*   Breaking implementation into clearly defined tasks uses blueprint sections as independent prompts effectively.
*   Modular implementation via AI allows generating or adapting code for specific components like database schema.
*   AI prompts explicitly use Greptile outputs, adapting existing snippets for new blueprint requirements accurately.
*   Using Greptile once more after implementation verifies alignment with previous successful patterns effectively.
*   Cross-checking against known best-practice PR descriptions ensures professional and consistent pull requests.
*   Prompting AI to draft a PR description using Greptile examples creates enterprise-level pull requests professionally.
*   A professional enterprise-level PR description includes checklists, summaries, screenshots, and potential impacts thoroughly.
*   The example workflow for "Slack Feedback Notification" demonstrates the practical application of the steps clearly.
*   Defining purpose, inputs, outputs, dependencies, components, and testing structures the feature planning comprehensively.
*   Greptile guarantees consistency with existing, vetted patterns within the codebase reliably and efficiently.
*   This integrated workflow results in reliable, scalable, and enterprise-quality pull requests consistently.

## INSIGHTS

*   Strategic integration of codebase search into AI workflows elevates development quality significantly.
*   Leveraging existing patterns through tools like Greptile prevents redundant work and ensures architectural harmony.
*   Blueprint-driven development combined with AI and search creates a robust, structured implementation process.
*   Validating design decisions against actual codebase examples improves reliability and reduces potential errors.
*   Modularizing implementation tasks guided by codebase insights streamlines development and increases efficiency.
*   Using AI to refine blueprints based on search results creates more practical and grounded feature designs.
*   Post-implementation validation using codebase search ensures adherence to established organizational patterns.
*   This workflow fosters a continuous loop of planning, searching, refining, implementing, and validating effectively.
*   Enterprise-quality development benefits significantly from systematic pattern identification and reuse practices.
*   Combining the power of AI generation with the context of existing code is highly synergistic.
*   The process ensures new features integrate seamlessly by building upon proven, existing infrastructure components.
*   Structured feature planning combined with codebase intelligence leads to more predictable and successful outcomes.

## QUOTES:

*   "Leveraging **Greptile** for Enterprise-Level Feature Implementation" - The guide
*   "Greptile excels at codebase search, identifying patterns, existing implementations, edge cases, and dependencies—making it invaluable for planning new features." - The guide
*   "Strategically integrate it into our blueprint-driven AI workflow to elevate your development process to enterprise standards." - The guide
*   "Generate a high-level feature blueprint as previously outlined." - The guide
*   "Define clear inputs, outputs, dependencies, edge cases, tests, and acceptance criteria." - The guide
*   "Before coding, perform a targeted **Greptile search** using keywords from your blueprint." - The guide
*   "This ensures we leverage existing patterns, preventing redundant work and guaranteeing architectural consistency." - The guide
*   "Using Greptile’s findings: Update your blueprint with proven patterns." - The guide
*   "Clearly identify reusable components." - The guide
*   "Specify integration points explicitly (e.g., extend existing webhook logic)." - The guide
*   "Using the Greptile search results \[paste summarized findings here], update the feature blueprint with the best matching existing components." - AI Prompt
*   "Break implementation into clearly defined tasks using blueprint sections as independent prompts." - The guide
*   "AI prompts use Greptile outputs explicitly: 'Given this existing Greptile result \[snippet], adapt it to implement the backend route defined in our blueprint.'" - The guide
*   "After implementation, use Greptile once more: Verify your implementation aligns with previous successful patterns." - The guide
*   "Cross-check against known best-practice PR descriptions in your org." - The guide
*   "Using the Greptile examples \[links/results] and the implemented blueprint, write a professional enterprise-level PR description, including checklist, implementation summary, screenshots, and potential impacts." - AI Prompt
*   "Blueprint ensures comprehensive feature planning." - The guide
*   "Greptile guarantees consistency with existing, vetted patterns." - The guide
*   "Result: Reliable, scalable, enterprise-quality PRs." - The guide

## HABITS

*   Always draft a high-level feature blueprint before starting any implementation work.
*   Consistently define clear inputs, outputs, and dependencies for every new feature component.
*   Systematically identify and document potential edge cases and required tests upfront in planning.
*   Regularly perform targeted codebase searches using keywords derived directly from the feature blueprint.
*   Make searching for existing similar implementations a mandatory step before writing new code.
*   Always look for relevant integration examples within the existing codebase to reuse patterns.
*   Check database schema examples to ensure consistency with existing data models and structures.
*   Review recent relevant pull requests or commits for context and successful implementation examples.
*   Refine initial blueprints based on findings from codebase searches to incorporate proven patterns.
*   Actively identify and document reusable components found during the codebase exploration phase.
*   Explicitly specify integration points in the blueprint, detailing how new code connects with existing systems.
*   Use search results to inform and refine AI prompts for blueprint updates and code generation tasks.
*   Break down implementation into smaller, modular tasks aligned with blueprint sections for clarity.
*   Explicitly reference codebase search results when providing context to AI for code adaptation.
*   Always validate implemented code against existing successful patterns using codebase search tools.
*   Cross-check drafted pull request descriptions against established best practices within the organization consistently.
*   Leverage AI to draft professional pull requests using codebase examples and the final blueprint details.

## REFERENCES

*   Greptile
*   AI
*   feature blueprint
*   endpoints/routes/services
*   Slack webhook integration
*   Database schema
*   PRs or commits
*   Slack Webhook Service
*   Feedback DB Model
*   Feedback form UI component
*   Feedback controller
*   Slack integration service
*   Slack webhook simulator
*   YAML format

## ONE-SENTENCE TAKEAWAY

Integrate codebase search with AI workflows using blueprints to build consistent, reliable, enterprise-quality features efficiently.

## RECOMMENDATIONS

*   Always begin feature development by generating a comprehensive, detailed high-level blueprint document.
*   Define all inputs, outputs, dependencies, and criteria meticulously within your initial feature blueprint.
*   Conduct targeted codebase searches using blueprint keywords *before* writing any new lines of code.
*   Seek out existing similar implementations, integration examples, and database schemas in the codebase.
*   Use specific search queries leveraging language, repository, and modification date filters effectively.
*   Ensure architectural consistency and prevent redundant work by leveraging identified existing patterns found.
*   Refine your initial blueprint by incorporating proven patterns discovered during the codebase search phase.
*   Clearly identify and document all reusable components found in the existing codebase for efficiency.
*   Explicitly specify how new features will integrate with existing systems by detailing connection points.
*   Provide summarized search results directly to AI when prompting for blueprint updates or code generation.
*   Break down the overall feature implementation into smaller, manageable tasks based on blueprint sections.
*   Supply specific code snippets from search results to AI for accurate code adaptation during implementation.
*   Perform a post-implementation codebase validation to verify alignment with established successful patterns.
*   Cross-reference your pull request description against known organizational best practices before submitting.
*   Utilize AI to generate a professional pull request draft incorporating search examples and blueprint details.
*   Structure feature planning comprehensively using purpose, inputs, outputs, dependencies, and testing definitions.
*   Guarantee consistency with existing, vetted patterns throughout the development lifecycle using search tools.
*   Focus on building reliable, scalable, enterprise-quality features by following this structured, integrated workflow.

### extract_instructions

### Objectives
- Integrate Greptile into an AI-assisted development workflow
- Leverage codebase search for enterprise-level feature planning
- Ensure architectural consistency by using existing patterns
- Refine feature blueprints based on search results
- Generate code modules and draft PRs referencing search findings

### Instructions
1.  **Draft AI Feature Blueprint:** Generate a high-level feature blueprint defining inputs, outputs, dependencies, edge cases, tests, and acceptance criteria.
2.  **Greptile Search & Validate:** Before coding, perform a targeted Greptile search using keywords from your blueprint to find existing similar code, integration examples, schemas, or recent commits.
    -   Use specific Greptile query examples based on your search needs (e.g., `language:typescript`, `repo:backend`, `modified:recent`).
3.  **AI-Enhanced Blueprint Refinement:** Use the summarized Greptile search results to update your blueprint.
    -   Identify reusable components and explicitly specify integration points.
    -   Prompt AI to update the blueprint based on the search findings.
4.  **Modular Implementation via AI:** Break the implementation into defined tasks (Database Schema, Backend Controller, Service Layer, Frontend, Tests).
    -   Use AI prompts for each task, explicitly referencing Greptile results (snippets or references) to generate or adapt code.
5.  **PR Drafting & Greptile Validation:** After implementing, use Greptile to verify your code aligns with previous successful patterns.
    -   Cross-check against known best-practice PR descriptions in your organization.
    -   Prompt AI to write a professional PR description using Greptile examples and the implemented blueprint.